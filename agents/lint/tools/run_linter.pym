from grail import Input, external
from typing import Any

check_only: bool = Input("check_only", default=False)
target_file_input: str | None = Input("target_file", default=None)


@external
async def read_file(path: str) -> str:
    """Read the text contents of a file."""
    ...


@external
async def file_exists(path: str) -> bool:
    """Check if a file or directory exists."""
    ...


@external
async def run_command(cmd: str, args: list[str]) -> dict[str, Any]:
    """Run a command in the sandbox."""
    ...


async def _read_optional(path: str) -> str | None:
    if await file_exists(path=path):
        return await read_file(path=path)
    return None


async def _resolve_target_file() -> str | None:
    if target_file_input:
        return target_file_input.strip()
    stored = await _read_optional(path=".remora/target_file")
    if stored:
        return stored.strip()
    return None


def _split_json_objects(text: str) -> list[str]:
    objects, depth, start = [], 0, None
    in_string, escape = False, False
    for idx, ch in enumerate(text):
        if in_string:
            escape = not escape and ch == "\\"
            if ch == '"' and not escape:
                in_string = False
            continue
        if ch == '"':
            in_string = True
            continue
        if ch == "{":
            if depth == 0:
                start = idx
            depth += 1
        elif ch == "}":
            depth -= 1
            if depth == 0 and start is not None:
                objects.append(text[start:idx + 1])
                start = None
    return objects


def _find_value_start(text: str, key: str) -> int | None:
    idx = text.find(f'"{key}":')
    return idx + len(f'"{key}":') if idx != -1 else None


def _parse_string(text: str) -> str:
    if not text.startswith('"'):
        return ""
    result, escape = [], False
    for ch in text[1:]:
        if escape:
            result.append(ch)
            escape = False
        elif ch == "\\":
            escape = True
        elif ch == '"':
            break
        else:
            result.append(ch)
    return "".join(result)


def _parse_number(text: str) -> int:
    digits = [ch for ch in text if ch.isdigit()]
    return int("".join(digits)) if digits else 0


def _extract_object(text: str) -> str:
    if not text.startswith("{"):
        return ""
    depth, in_string, escape = 0, False, False
    for idx, ch in enumerate(text):
        if in_string:
            escape = not escape and ch == "\\"
            if ch == '"' and not escape:
                in_string = False
            continue
        if ch == '"':
            in_string = True
            continue
        if ch == "{":
            depth += 1
        elif ch == "}":
            depth -= 1
            if depth == 0:
                return text[:idx + 1]
    return ""


def _get_string(obj: str, key: str) -> str:
    start = _find_value_start(obj, key)
    return _parse_string(obj[start:].lstrip()) if start else ""


def _get_int(obj: str, key: str) -> int:
    start = _find_value_start(obj, key)
    return _parse_number(obj[start:].lstrip()) if start else 0


def _get_object(obj: str, key: str) -> str:
    start = _find_value_start(obj, key)
    return _extract_object(obj[start:].lstrip()) if start else ""


def _format_issue(issue: str) -> dict[str, Any]:
    location, fix = _get_object(issue, "location"), _get_object(issue, "fix")
    applicability = _get_string(fix, "applicability") if fix else ""
    return {
        "code": _get_string(issue, "code"),
        "line": _get_int(location, "row"),
        "col": _get_int(location, "column"),
        "message": _get_string(issue, "message"),
        "fixable": bool(fix and applicability != "unfixable"),
    }


try:
    target_file = await _resolve_target_file()
    if not target_file:
        raise FileNotFoundError("Target file not found for linting.")

    command_args = ["check", "--output-format", "json"]
    if not check_only:
        command_args.append("--fix")
    command_args.append(target_file)

    completed = await run_command(cmd="ruff", args=command_args)
    exit_code = int(completed.get("exit_code", 0) or 0)
    stderr = str(completed.get("stderr", ""))
    stdout = str(completed.get("stdout", ""))

    if exit_code not in {0, 1}:
        result = {"error": stderr.strip() or f"ruff exit code {exit_code}"}
    else:
        issues_raw = _split_json_objects(stdout)
        issues = [_format_issue(issue) for issue in issues_raw]
        fixable_count = sum(1 for issue in issues if issue.get("fixable"))
        result = {"issues": issues, "total": len(issues), "fixable_count": fixable_count}
except Exception as exc:
    result = {"error": str(exc)}

result
