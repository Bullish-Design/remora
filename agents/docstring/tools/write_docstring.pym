from __future__ import annotations

from pathlib import Path
import ast
import json
import os
from typing import Any


def _workspace_root() -> Path:
    workspace = os.getenv("REMORA_WORKSPACE_DIR") or os.getenv("CAIRN_WORKSPACE_DIR")
    return Path(workspace) if workspace else Path.cwd()


def _resolve_target_file() -> Path:
    workspace_root = _workspace_root()
    env_path = os.getenv("REMORA_TARGET_FILE")
    if env_path:
        path = Path(env_path)
        return path if path.is_absolute() else workspace_root / path

    hint_path = workspace_root / ".remora" / "target_file"
    if hint_path.exists():
        raw = hint_path.read_text(encoding="utf-8").strip()
        if raw:
            path = Path(raw)
            return path if path.is_absolute() else workspace_root / path

    raise FileNotFoundError("Target file not found for docstring insertion.")


def _load_node_text() -> str | None:
    env_text = os.getenv("REMORA_NODE_TEXT")
    if env_text:
        return env_text

    workspace_root = _workspace_root()
    hint_path = workspace_root / ".remora" / "node_text"
    if hint_path.exists():
        return hint_path.read_text(encoding="utf-8")

    return None


def _extract_function_name(node_text: str | None) -> str | None:
    if not node_text:
        return None
    try:
        module = ast.parse(node_text)
    except Exception:
        return None
    for node in module.body:
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            return node.name
    return None


def _find_function(module: ast.Module, name: str | None) -> ast.FunctionDef | ast.AsyncFunctionDef | None:
    for node in ast.walk(module):
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            if name is None or node.name == name:
                return node
    return None


def _line_indent(line: str) -> str:
    return line[: len(line) - len(line.lstrip(" \t"))]


def _format_docstring(docstring: str, indent: str) -> list[str]:
    lines = docstring.splitlines()
    if not lines:
        return [f"{indent}\"\"\"\"\"\""]
    if len(lines) == 1:
        return [f"{indent}\"\"\"{lines[0]}\"\"\""]
    formatted = [f"{indent}\"\"\""]
    formatted.extend(f"{indent}{line}" for line in lines)
    formatted.append(f"{indent}\"\"\"")
    return formatted


def _is_docstring_expr(node: ast.AST) -> bool:
    if not isinstance(node, ast.Expr):
        return False
    value = node.value
    if isinstance(value, ast.Constant):
        return isinstance(value.value, str)
    return isinstance(value, ast.Str)


def _apply_docstring(
    lines: list[str],
    func: ast.FunctionDef | ast.AsyncFunctionDef,
    docstring_lines: list[str],
) -> tuple[list[str], bool]:
    if func.body and _is_docstring_expr(func.body[0]):
        doc_node = func.body[0]
        start = (doc_node.lineno or 1) - 1
        end = (doc_node.end_lineno or doc_node.lineno or 1) - 1
        lines[start : end + 1] = docstring_lines
        return lines, True

    if func.body:
        insert_at = (func.body[0].lineno or (func.lineno or 1)) - 1
    else:
        insert_at = (func.end_lineno or func.lineno or 1)
    lines[insert_at:insert_at] = docstring_lines
    return lines, False


def run(inputs: dict[str, Any]) -> dict[str, Any]:
    try:
        docstring = str(inputs.get("docstring", ""))
        if not docstring:
            raise ValueError("Docstring text is required.")

        target = _resolve_target_file()
        content = target.read_text(encoding="utf-8")
        trailing_newline = content.endswith("\n")
        lines = content.splitlines()

        node_text = _load_node_text()
        function_name = _extract_function_name(node_text)

        module = ast.parse(content)
        func = _find_function(module, function_name)
        if func is None:
            raise ValueError("Function definition not found in target file.")

        indent = "    "
        if func.body:
            body_line_index = (func.body[0].lineno or 1) - 1
            if 0 <= body_line_index < len(lines):
                indent = _line_indent(lines[body_line_index]) or indent
        elif func.lineno and 0 <= func.lineno - 1 < len(lines):
            indent = _line_indent(lines[func.lineno - 1]) + indent

        docstring_lines = _format_docstring(docstring, indent)
        updated_lines, replaced_existing = _apply_docstring(lines, func, docstring_lines)
        updated_content = "\n".join(updated_lines)
        if trailing_newline:
            updated_content += "\n"
        target.write_text(updated_content, encoding="utf-8")
        return {"success": True, "replaced_existing": replaced_existing}
    except Exception as exc:  # noqa: BLE001 - tool scripts must never raise
        return {"success": False, "error": str(exc)}


if __name__ == "__main__":
    payload = json.loads(os.environ.get("REMORA_INPUT", "{}"))
    print(json.dumps(run(payload)))
