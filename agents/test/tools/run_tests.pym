from grail import Input, external
from typing import Any

path_input: str | None = Input("path", default=None)
target_file_input: str | None = Input("target_file", default=None)


@external
async def read_file(path: str) -> str:
    """Read the text contents of a file."""
    ...


@external
async def file_exists(path: str) -> bool:
    """Check if a file or directory exists."""
    ...


@external
async def run_command(cmd: str, args: list[str]) -> dict[str, Any]:
    """Run a command in the sandbox."""
    ...


async def _read_optional(path: str) -> str | None:
    if await file_exists(path=path):
        return await read_file(path=path)
    return None


async def _resolve_target_file() -> str | None:
    if target_file_input:
        return target_file_input.strip()
    stored = await _read_optional(path=".remora/target_file")
    if stored:
        return stored.strip()
    return None


def _default_test_path(target_file: str) -> str:
    filename = target_file.split("/")[-1]
    module_name = filename.rsplit(".", 1)[0]
    return f"tests/test_{module_name}.py"


def _read_attr(tag: str, key: str) -> int:
    marker = f"{key}=\""
    if marker not in tag:
        return 0
    value = tag.split(marker, 1)[1].split("\"", 1)[0]
    try:
        return int(value)
    except Exception:
        return 0


def _parse_totals(xml: str) -> dict[str, int]:
    totals = {"tests": 0, "failures": 0, "errors": 0, "skipped": 0}
    index = 0
    while True:
        start = xml.find("<testsuite", index)
        if start == -1:
            break
        end = xml.find(">", start)
        if end == -1:
            break
        tag = xml[start:end]
        for key in totals:
            totals[key] += _read_attr(tag, key)
        index = end + 1
    return totals


def _read_str_attr(tag: str, key: str) -> str:
    marker = f"{key}=\""
    if marker not in tag:
        return ""
    return tag.split(marker, 1)[1].split("\"", 1)[0]


def _extract_failure_detail(block: str, tag: str) -> str:
    start = block.find(f"<{tag}")
    if start == -1:
        return ""
    end_tag = block.find(">", start)
    if end_tag == -1:
        return ""
    header = block[start:end_tag]
    message = _read_str_attr(header, "message")
    if message:
        return message.strip()
    close = block.find(f"</{tag}>", end_tag)
    if close == -1:
        return ""
    return block[end_tag + 1 : close].strip()


def _parse_failures(xml: str) -> list[dict[str, str]]:
    failures: list[dict[str, str]] = []
    index = 0
    while True:
        start = xml.find("<testcase", index)
        if start == -1:
            break
        end = xml.find(">", start)
        if end == -1:
            break
        tag = xml[start:end]
        name = _read_str_attr(tag, "name")
        classname = _read_str_attr(tag, "classname")
        full_name = f"{classname}::{name}" if classname else name
        close = xml.find("</testcase>", end)
        if close == -1:
            index = end + 1
            continue
        body = xml[end:close]
        detail = ""
        if "<failure" in body:
            detail = _extract_failure_detail(body, "failure")
        elif "<error" in body:
            detail = _extract_failure_detail(body, "error")
        if detail:
            failures.append({"test": full_name, "message": detail})
        index = close + len("</testcase>")
    return failures


try:
    target_file = await _resolve_target_file()
    test_path = path_input.strip() if path_input else None
    if not test_path:
        if not target_file:
            raise FileNotFoundError("Target file not found for tests.")
        test_path = _default_test_path(target_file)

    if not await file_exists(path=test_path):
        raise FileNotFoundError(f"Test file not found: {test_path}")

    report_path = ".remora/pytest_report.xml"
    command_args = [
        "-q",
        "--disable-warnings",
        f"--junitxml={report_path}",
        test_path,
    ]
    completed = await run_command(cmd="pytest", args=command_args)
    stdout = str(completed.get("stdout", ""))
    stderr = str(completed.get("stderr", ""))
    exit_code = int(completed.get("exit_code", 0) or 0)

    if not await file_exists(path=report_path):
        raise RuntimeError(stderr.strip() or stdout.strip() or "Pytest report not generated.")

    xml = await read_file(path=report_path)
    totals = _parse_totals(xml)
    failures = _parse_failures(xml)

    passed = totals["tests"] - totals["failures"] - totals["errors"] - totals["skipped"]
    result = {
        "passed": max(passed, 0),
        "failed": totals["failures"],
        "errors": totals["errors"],
        "failures": failures,
    }

    if exit_code not in {0, 1}:
        result["errors"] = max(result.get("errors", 0), 1)
        result["failures"].append(
            {
                "test": "pytest",
                "message": stderr.strip() or stdout.strip() or "Pytest failed to run.",
            }
        )
except Exception as exc:
    result = {"error": str(exc), "passed": 0, "failed": 0, "errors": 1, "failures": []}

result
