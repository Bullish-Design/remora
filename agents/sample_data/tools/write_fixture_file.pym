from __future__ import annotations

from pathlib import Path
import ast
import json
import os
from typing import Any

import yaml


def _workspace_root() -> Path:
    workspace = os.getenv("REMORA_WORKSPACE_DIR") or os.getenv("CAIRN_WORKSPACE_DIR")
    return Path(workspace) if workspace else Path.cwd()


def _resolve_target_file() -> Path | None:
    workspace_root = _workspace_root()
    env_path = os.getenv("REMORA_TARGET_FILE")
    if env_path:
        path = Path(env_path)
        return path if path.is_absolute() else workspace_root / path

    hint_path = workspace_root / ".remora" / "target_file"
    if hint_path.exists():
        raw = hint_path.read_text(encoding="utf-8").strip()
        if raw:
            path = Path(raw)
            return path if path.is_absolute() else workspace_root / path

    return None


def _load_node_text() -> str:
    env_text = os.getenv("REMORA_NODE_TEXT")
    if env_text:
        return env_text

    workspace_root = _workspace_root()
    hint_path = workspace_root / ".remora" / "node_text"
    if hint_path.exists():
        return hint_path.read_text(encoding="utf-8")

    target = _resolve_target_file()
    if target and target.exists():
        return target.read_text(encoding="utf-8")

    return ""


def _resolve_function_name() -> str:
    source = _load_node_text()
    if not source:
        return "fixture"
    try:
        module = ast.parse(source)
    except SyntaxError:
        return "fixture"
    for node in module.body:
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
            return node.name
    return "fixture"


def _relative_path(path: Path) -> str:
    workspace_root = _workspace_root()
    try:
        return str(path.relative_to(workspace_root))
    except ValueError:
        return str(path)


def _serialize_fixtures(fixtures: list[object], fmt: str) -> tuple[str, str]:
    fmt = fmt.lower()
    if fmt in {"yaml", "yml"}:
        content = yaml.safe_dump(fixtures, sort_keys=False)
        return content, "yaml"
    if fmt != "json":
        raise ValueError(f"Unsupported fixture format: {fmt}")
    content = json.dumps(fixtures, indent=2)
    return content, "json"


def run(inputs: dict[str, Any]) -> dict[str, Any]:
    try:
        fixtures = inputs.get("fixtures")
        if not isinstance(fixtures, list) or not fixtures:
            raise ValueError("Fixtures must be a non-empty list.")

        fmt = str(inputs.get("format", "json"))
        content, extension = _serialize_fixtures(fixtures, fmt)
        function_name = _resolve_function_name()
        target_path = _workspace_root() / "fixtures" / f"{function_name}_fixtures.{extension}"
        target_path.parent.mkdir(parents=True, exist_ok=True)
        target_path.write_text(content, encoding="utf-8")
        return {"success": True, "path": _relative_path(target_path)}
    except Exception as exc:  # noqa: BLE001 - tool scripts must never raise
        return {"success": False, "error": str(exc)}


if __name__ == "__main__":
    payload = json.loads(os.environ.get("REMORA_INPUT", "{}"))
    print(json.dumps(run(payload)))
