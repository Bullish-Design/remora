# Auto-generated by grail â€” this is what Monty actually executes

from typing import Any

async def _read_optional(path: str) -> str | None:
    if await file_exists(path=path):
        return await read_file(path=path)
    return None

async def _resolve_target_file() -> str | None:
    if target_file_input:
        return target_file_input.strip()
    stored = await _read_optional(path='.remora/target_file')
    if stored:
        return stored.strip()
    return None

def _split_json_objects(text: str) -> list[str]:
    objects, depth, start = ([], 0, None)
    in_string, escape = (False, False)
    for idx, ch in enumerate(text):
        if in_string:
            escape = not escape and ch == '\\'
            if ch == '"' and (not escape):
                in_string = False
            continue
        if ch == '"':
            in_string = True
            continue
        if ch == '{':
            if depth == 0:
                start = idx
            depth += 1
        elif ch == '}':
            depth -= 1
            if depth == 0 and start is not None:
                objects.append(text[start:idx + 1])
                start = None
    return objects

def _find_value_start(text: str, key: str) -> int | None:
    idx = text.find(f'"{key}":')
    return idx + len(f'"{key}":') if idx != -1 else None

def _parse_string(text: str) -> str:
    if not text.startswith('"'):
        return ''
    result, escape = ([], False)
    for ch in text[1:]:
        if escape:
            result.append(ch)
            escape = False
        elif ch == '\\':
            escape = True
        elif ch == '"':
            break
        else:
            result.append(ch)
    return ''.join(result)

def _parse_number(text: str) -> int:
    digits = [ch for ch in text if ch.isdigit()]
    return int(''.join(digits)) if digits else 0

def _extract_object(text: str) -> str:
    if not text.startswith('{'):
        return ''
    depth, in_string, escape = (0, False, False)
    for idx, ch in enumerate(text):
        if in_string:
            escape = not escape and ch == '\\'
            if ch == '"' and (not escape):
                in_string = False
            continue
        if ch == '"':
            in_string = True
            continue
        if ch == '{':
            depth += 1
        elif ch == '}':
            depth -= 1
            if depth == 0:
                return text[:idx + 1]
    return ''

def _get_string(obj: str, key: str) -> str:
    start = _find_value_start(obj, key)
    return _parse_string(obj[start:].lstrip()) if start else ''

def _get_int(obj: str, key: str) -> int:
    start = _find_value_start(obj, key)
    return _parse_number(obj[start:].lstrip()) if start else 0

def _get_object(obj: str, key: str) -> str:
    start = _find_value_start(obj, key)
    return _extract_object(obj[start:].lstrip()) if start else ''

def _format_issue(issue: str) -> dict[str, Any]:
    location, fix = (_get_object(issue, 'location'), _get_object(issue, 'fix'))
    applicability = _get_string(fix, 'applicability') if fix else ''
    return {'code': _get_string(issue, 'code'), 'line': _get_int(location, 'row'), 'col': _get_int(location, 'column'), 'message': _get_string(issue, 'message'), 'fixable': bool(fix and applicability != 'unfixable')}
try:
    target_file = await _resolve_target_file()
    if not target_file:
        raise ValueError('Target file not found for linting.')
    command_args = ['check', '--output-format', 'json']
    if not check_only:
        command_args.append('--fix')
    command_args.append(target_file)
    completed = await run_command(cmd='ruff', args=command_args)
    exit_code = int(completed.get('exit_code', 0) or 0)
    stderr = str(completed.get('stderr', ''))
    stdout = str(completed.get('stdout', ''))
    if exit_code not in {0, 1}:
        error_message = stderr.strip() or f'ruff exit code {exit_code}'
        result = {'result': None, 'summary': f'Error: {error_message}', 'knowledge_delta': {}, 'outcome': 'error', 'error': error_message}
    else:
        issues_raw = _split_json_objects(stdout)
        issues = [_format_issue(issue) for issue in issues_raw]
        fixable_count = sum((1 for issue in issues if issue.get('fixable')))
        total = len(issues)
        raw_result = {'issues': issues, 'total': total, 'fixable_count': fixable_count}
        if total == 0:
            summary = 'No lint errors found'
            outcome = 'success'
        elif fixable_count > 0:
            summary = f'Found {total} lint errors, {fixable_count} fixable'
            outcome = 'partial'
        else:
            summary = f'Found {total} lint errors'
            outcome = 'partial'
        result = {'result': raw_result, 'summary': summary, 'knowledge_delta': {'lint_errors_remaining': total, 'lint_errors_fixable': fixable_count}, 'outcome': outcome}
except Exception as exc:
    result = {'result': None, 'summary': f'Error: {exc}', 'knowledge_delta': {}, 'outcome': 'error', 'error': str(exc)}
result