# Auto-generated by grail â€” this is what Monty actually executes

from typing import Any

async def _read_optional(path: str) -> str | None:
    if await file_exists(path=path):
        return await read_file(path=path)
    return None

async def _resolve_target_file() -> str | None:
    if target_file_input:
        return target_file_input.strip()
    stored = await _read_optional(path='.remora/target_file')
    if stored:
        return stored.strip()
    return None
try:
    if not issue_code or line_number <= 0:
        result = {'success': False, 'message': 'issue_code and line_number are required.'}
    else:
        target_file = await _resolve_target_file()
        if not target_file:
            raise ValueError('Target file not found for linting.')
        before = await read_file(path=target_file)
        command_args = ['check', '--fix', '--select', issue_code, target_file]
        completed = await run_command(cmd='ruff', args=command_args)
        exit_code = int(completed.get('exit_code', 0) or 0)
        stderr = str(completed.get('stderr', ''))
        if exit_code not in {0, 1}:
            result = {'success': False, 'message': stderr.strip() or f'ruff exit code {exit_code}'}
        else:
            after = await read_file(path=target_file)
            if before == after:
                result = {'success': False, 'message': 'No fixable issue at that location'}
            else:
                result = {'success': True, 'message': f'Applied fix for {issue_code} at line {line_number}'}
except Exception as exc:
    result = {'success': False, 'message': str(exc)}
result