# Auto-generated by grail â€” this is what Monty actually executes

"""Extract function/class signatures from a Python file."""
from typing import Any

def _simple_hash(text: str) -> str:
    value = 0
    for ch in text:
        value = (value * 31 + ord(ch)) % 1000000007
    return str(value)

def _block_end(lines: list[str], start_index: int, base_indent: int) -> int:
    for index in range(start_index + 1, len(lines)):
        line = lines[index]
        stripped = line.strip()
        if not stripped:
            continue
        indent = len(line) - len(line.lstrip())
        if indent <= base_indent:
            return index
    return len(lines)

def _extract_docstring(lines: list[str], start_index: int, base_indent: int) -> str | None:
    for index in range(start_index + 1, len(lines)):
        line = lines[index]
        stripped = line.strip()
        if not stripped:
            continue
        indent = len(line) - len(line.lstrip())
        if indent <= base_indent:
            return None
        if stripped.startswith('"""') or stripped.startswith("'''"):
            quote = stripped[:3]
            remainder = stripped[3:]
            if remainder.endswith(quote):
                return remainder[:-3].strip()
            content_lines: list[str] = []
            if remainder:
                content_lines.append(remainder)
            for inner_index in range(index + 1, len(lines)):
                inner_line = lines[inner_index]
                if quote in inner_line:
                    before = inner_line.split(quote, 1)[0]
                    content_lines.append(before)
                    return '\n'.join(content_lines).strip()
                content_lines.append(inner_line.strip())
            return '\n'.join(content_lines).strip()
        return None
    return None

def _extract_function(lines: list[str], start_index: int, signature_line: str, decorators: list[str]) -> dict[str, Any]:
    base_indent = len(lines[start_index]) - len(lines[start_index].lstrip())
    end_index = _block_end(lines, start_index, base_indent)
    func_source = '\n'.join(lines[start_index:end_index])
    source_hash = _simple_hash(func_source)
    signature = signature_line.rstrip(':')
    docstring = _extract_docstring(lines, start_index, base_indent)
    if docstring:
        docstring = docstring.split('\n')[0][:100]
    has_type_hints = '->' in signature or ':' in signature
    return {'name': signature.split('(', 1)[0].split()[-1], 'type': 'function', 'signature': signature, 'docstring': docstring, 'decorators': decorators, 'source_hash': source_hash, 'line_count': end_index - start_index, 'has_type_hints': has_type_hints, 'start_line': start_index + 1, 'end_line': end_index}

def _extract_class(lines: list[str], start_index: int, signature_line: str, decorators: list[str]) -> dict[str, Any]:
    base_indent = len(lines[start_index]) - len(lines[start_index].lstrip())
    end_index = _block_end(lines, start_index, base_indent)
    class_source = '\n'.join(lines[start_index:end_index])
    source_hash = _simple_hash(class_source)
    signature = signature_line.rstrip(':')
    docstring = _extract_docstring(lines, start_index, base_indent)
    if docstring:
        docstring = docstring.split('\n')[0][:100]
    name = signature.split('(', 1)[0].split()[1]
    return {'name': name, 'type': 'class', 'signature': signature, 'docstring': docstring, 'decorators': decorators, 'source_hash': source_hash, 'line_count': end_index - start_index, 'has_type_hints': False, 'start_line': start_index + 1, 'end_line': end_index}
try:
    content = await read_file(file_path)
    lines = content.splitlines()
    nodes: list[dict[str, Any]] = []
    decorators_buffer: list[str] = []
    for index, line in enumerate(lines):
        stripped = line.strip()
        if not stripped:
            continue
        if stripped.startswith('@'):
            decorators_buffer.append(stripped)
            continue
        if stripped.startswith('async def ') or stripped.startswith('def '):
            nodes.append(_extract_function(lines, index, stripped, decorators_buffer))
            decorators_buffer = []
            continue
        if stripped.startswith('class '):
            nodes.append(_extract_class(lines, index, stripped, decorators_buffer))
            decorators_buffer = []
            continue
        decorators_buffer = []
    result = {'file_path': file_path, 'file_hash': _simple_hash(content), 'nodes': nodes, 'error': None}
except Exception as exc:
    result = {'file_path': file_path, 'error': f'Failed to extract signatures: {exc}', 'nodes': []}
result