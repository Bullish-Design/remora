# Auto-generated by grail â€” this is what Monty actually executes

from __future__ import annotations
from typing import Any

def _build_partial_result(message: str) -> dict[str, Any]:
    return {'result': {'success': False, 'message': message}, 'summary': message, 'knowledge_delta': {'fix_applied': False, 'last_fix_issue_code': issue_code, 'last_fix_line': line_number}, 'outcome': 'partial'}
try:
    if not source_code:
        raise ValueError('Source code is required.')
    if not issue_code or line_number <= 0:
        raise ValueError('issue_code and line_number are required.')
    candidate_content = fixed_content if fixed_content is not None else source_code
    if exit_code not in {0, 1}:
        error_message = stderr.strip() or f'ruff exit code {exit_code}'
        result = {'result': {'success': False, 'message': error_message}, 'summary': f'Error: {error_message}', 'knowledge_delta': {'fix_applied': False, 'last_fix_issue_code': issue_code, 'last_fix_line': line_number}, 'outcome': 'error', 'error': error_message}
    else:
        content_changed = candidate_content != source_code
        if content_changed:
            await write_file(file_path, candidate_content)
            message = f'Applied fix for {issue_code} at line {line_number}'
            result = {'result': {'success': True, 'message': message, 'fixed_code': candidate_content}, 'summary': message, 'knowledge_delta': {'fix_applied': True, 'last_fix_issue_code': issue_code, 'last_fix_line': line_number}, 'outcome': 'success', 'written_file': file_path, 'content': candidate_content}
        else:
            result = _build_partial_result(f'No fixable issue for {issue_code} at line {line_number}')
except Exception as exc:
    result = {'result': {'success': False, 'message': str(exc)}, 'summary': f'Error: {exc}', 'knowledge_delta': {}, 'outcome': 'error', 'error': str(exc)}
result